@page "/FASCICOLO_GARA/GeneraZip.asp"
@inject eProcurementNext.Session.ISession session;
@using eProcurementNext.CommonDB
@using eProcurementNext.Core.Storage
@using eProcurementNext.CommonModule;
@using static eProcurementNext.CommonModule.Basic;
@using eProcurementNext.BizDB;
@using eProcurementNext.Application;
@using Microsoft.VisualBasic;
@using static eProcurementNext.Razor.Pages.CTL_LIBRARY.functions.securityModel
@using static eProcurementNext.Razor.Pages.CTL_LIBRARY.functions.net_utilsModel
@using static eProcurementNext.Razor.Pages.CTL_LIBRARY.DOCUMENT.CommonModel
@model eProcurementNext.Razor.Pages.FASCICOLO_GARA.GeneraZipModel
@using static eProcurementNext.Session.SessionMiddleware
@using Basic = eProcurementNext.CommonDB.Basic
@{
    CommonDbFunctions cdf = new();
    LoadSession(HttpContext, session);
    EprocResponse htmlToReturn = new();

    //'--questa pagina viene chiamata per ogni allegato con MODE=stringa vuota che deve essere aggiunto allo ZIP del fascicolo di gara
    //'--e viene chiamata con MODE=PRODUZIONE_ZIP  e sempre un id di un allegato a caso per generare lo ZIP finale

    //'--recupero cosa deve fare l apagina
    //'--MODE=stringa vuota aggiunge allegato alla cartella destinazione
    //'--MODE=PRODUZIONE_ZIP produce lo zip a partire dalla cartella sorgente che si chiama <ProtocolloGara>_<Gic>
    string MODE = GetParamURL(Request.QueryString.ToString(), "MODE");

    //'--recupero id della riga della tabella Document_Fascicolo_Gara_Allegati
    string idRow = GetParamURL(Request.QueryString.ToString(), "id");

    validate("id", idRow, TIPO_PARAMETRO_INT, SOTTO_TIPO_VUOTO, "", 1, HttpContext, session);
    validate("MODE", MODE, TIPO_PARAMETRO_STRING, SOTTO_TIPO_VUOTO, "", 0, HttpContext, session);

    TSRecordSet? rs;
    string PercorsoDiRete;
    string NomeZip = string.Empty;
    string NomeFile = string.Empty;
    string PathFile = string.Empty;
    string Attach = string.Empty;
    string[] aInfoHash;
    string Hash_Attach = string.Empty;

    //'--recupero la forma tecnica dell'allegato dalla tabella

    //'--recupero path di rete dove salvare lo ZIP del fascicolo di gara
    string strSQL = @"select PercorsoDiRete from CTL_DOC with (nolock)
								inner join Document_Config_FascicoloGara with (nolock) on idheader = Id
	 							where tipodoc='parametri_fascicolo_gara' and statofunzionale='confermato' ";
    try
    {
        rs = cdf.GetRSReadFromQuery_(strSQL, ApplicationCommon.Application.ConnectionString);
    }
    catch
    {
        htmlToReturn.Write($@"1#KO - errore statement: {strSQL}");
        throw new ResponseEndException(htmlToReturn.Out(), Response, $@"1#KO - errore statement: {strSQL}");
    }

    if (rs.RecordCount > 0)
    {
        rs.MoveFirst();
        PercorsoDiRete = CStr(rs["PercorsoDiRete"]);
    }
    else
    {
        htmlToReturn.Write("1#KO - errore PercorsoDiRete non trovato");
        Basic.LogEvent(Basic.TsEventLogEntryType.Warning, "errore PercorsoDiRete non trovato", ApplicationCommon.Application.ConnectionString, "FASCICOLO_GARA.GeneraZip");
        throw new ResponseEndException(htmlToReturn.Out(), Response, "1#KO - errore PercorsoDiRete non trovato");
    }

    //'--recupero info dell'allegato da aggiungere allo ZIP del fascicolo di gara
    var sqlParams = new Dictionary<string, object?> { { "@idRow", CInt(idRow) } };

    strSQL = @"select ProtocolloRiferimento, NumeroDocumento, isnull(Path,'') as path, Attach, isnull(NomeFile,'') as NomeFile
						from Document_Fascicolo_Gara_Allegati with (nolock)
						inner join CTL_DOC with (nolock) on Id = IdHeader
						where idRow = @idRow";
    try
    {
        rs = cdf.GetRSReadFromQuery_(strSQL, ApplicationCommon.Application.ConnectionString, sqlParams);
    }
    catch
    {
        htmlToReturn.Write($"0#KO - errore statement: {strSQL}");
        throw new ResponseEndException(htmlToReturn.Out(), Response, $"0#KO - errore statement: {strSQL}");
    }

    if (rs is null || rs.RecordCount <= 0)
    {
        throw new Exception($"Recupero info allegato da caricare nel fascicolo fallito. RecordCount 0 per la query {strSQL}");
    }

    rs.MoveFirst();

    //'--nome dello zip
    NomeZip = $"{CStr(rs["ProtocolloRiferimento"])}_{CStr(rs["NumeroDocumento"])}";

    //'--nome file
    NomeFile = CStr(rs["NomeFile"]);

    //'--path dove salvare il file
    PathFile = CStr(rs["path"]);

    //'--valore tecnico dell'allegato
    Attach = CStr(rs["Attach"]);
    

    //'--IN CASO DI SHARED DI RETE E PRESENZA DELLE SYS EFFETTUO MAP DELLA SHARED CON DRIVE LOGICO
    string tmpBase = MAP_SHARE_WITH_DRIVE(PercorsoDiRete);

    //'--aggiungo al percorso di rete il nome dello ZIP del fascicolo in modo da non mischiare i documenti di fascicoli diversi
    string tmpCurr = $@"{tmpBase}{NomeZip}\";

    string tmpBaseZip = tmpCurr;

    //'--se MODE vuoto aggiungo allegato alla cartella destinazione
    if (string.IsNullOrEmpty(MODE))
    {
        //'--INIZIO AGGIUNGI ALLEGATO ALLA CARTELLA

        //'--aggiungo allegato allo ZIP
        if (!CommonStorage.ExistsDirectory(tmpCurr))
        {
            //'--se la cartella non esiste la creo
            try
            {
                CommonStorage.CreateDirectory(tmpCurr);
            }
            catch (Exception ex)
            {
                //'--in caso di errore provo a cancellare la cartella temporanea appena creata e mi fermo
                htmlToReturn.Write($@"1#KO - errore accesso al path di rete:{tmpCurr}<br>{ex.Message}<br>" + ex.Source);
                throw new ResponseEndException(htmlToReturn.Out(), Response, "1#KO - errore accesso al path di rete:");
            }
        }

        //'--per ogni cartella contenuta nel path file vado a creare la directory
        string[] aInfoPath = Strings.Split(PathFile, @"\");

        for (int i = 0; i <= aInfoPath.Length - 1; i++)
        {
            //KPF 495186 per togliere eventuali spazi e per togliere il doppio\\
            tmpCurr = $@"{tmpCurr}{Trim(aInfoPath[i])}\";

            if (!CommonStorage.ExistsDirectory(tmpCurr))
            {
                try
                {
                    //'--se la cartella non esiste la creo
                    CommonStorage.CreateDirectory(tmpCurr);
                }
                catch (Exception ex)
                {
                    htmlToReturn.Write($@"1#KO - errore accesso al path di rete:{tmpCurr}<br>{ex.Message}<br>{ex.Source}");
                    throw new ResponseEndException(htmlToReturn.Out(), Response, $@"1#KO - errore accesso al path di rete:{tmpCurr}<br>{ex.Message}<br>{ex.Source}");
                }
            }
        }

        //'--recupero hash dell'allegato
        aInfoHash = Strings.Split(Attach, "*");
        Hash_Attach = aInfoHash[3];

        //'--se il nome file vuoto prendo quello indicato nel campo tecnico
        if (string.IsNullOrEmpty(NomeFile))
        {
            NomeFile = aInfoHash[0];
        }

        sqlParams.Clear();
       
        //string path_file_not_ok = "NO";  Migliorata la gestione tra vbscript e c#: variabile non necessaria soprattutto nella gestione dell'eccezione
      
        try
        {
            //'salvo allegato sul disco nel path indicato da folderCurr e con NomeFile

            // Aggiungo questo controllo per evitare che non vengano inseriti file nel fascicolo con path superiore a 255
            if (tmpCurr.Length + NomeFile.Length <= 255)
            {
                //'--recupero blob dell'allegato
                Basic.saveFileFromRecordSet("Att_Obj", "ctl_attach", "att_hash", Hash_Attach, tmpCurr + NomeFile, ApplicationCommon.Application.ConnectionString);
            }
            else
            {
                
                Basic.LogEvent(Basic.TsEventLogEntryType.Warning, $"Il file {tmpCurr.Length + NomeFile.Length} supera i 255 caratteri", ApplicationCommon.Application.ConnectionString,"FASCICOLO_GARA.GeneraZip");

                throw new Exception("Il path del file supera i 255 caratteri");
            }

        }
        catch (Exception ex)
        {
            //'--in caso di errore (fine spazio ad esempio) o mancato recupero di un attach
            htmlToReturn.Write($@"1#KO - errore save allegato sul disco in: " + CStr(tmpCurr + NomeFile) + "<br>" + ex.Message + "<br>" + ex.Source);
            throw new ResponseEndException(htmlToReturn.Out(), Response, $"1#KO - errore save allegato sul disco in: {tmpCurr + NomeFile}<br>{ex.Message}<br>{ex.Source}");
        }

        //'--FINE AGGIUNGI ALLEGATO ALLA CARTELLA
    }

    //'--facciamo lo ZIP solo alla fine se MODE=PRODUZIONE_ZIP
    if (MODE == "PRODUZIONE_ZIP")
    {
        
        try
        {
            //'--aggiungo il file allo zip complessivo nel percorso di rete indicato
            //'--da verificare che se la cartella nello zip già esiste va in aggiunta
            new Zip().Pack(tmpBaseZip, tmpBase + NomeZip + ".zip");
        }
        catch
        {
            htmlToReturn.Write($@"1#KO");
            throw new ResponseEndException(htmlToReturn.Out(), Response, "1#KO");
        }

        //'--se MODE=PRODUZIONE_ZIP  cancelliamo la cartella sorgente tmpBaseZip

        if (CommonStorage.ExistsDirectory(tmpBaseZip))
        {
            //'--se la cartella esiste la recupero e la cancello
            try
            {
                CommonStorage.DeleteDirectory(tmpBaseZip);
            }
            catch
            {
                htmlToReturn.Write($@"1#KO - errore cancellazione cartella sorgente dello zip");
                throw new ResponseEndException(htmlToReturn.Out(), Response, "1#KO - errore cancellazione cartella sorgente dello zip");
            }
        }
        else
        {
            htmlToReturn.Write($@"1#KO - cartella sorgente dello zip non esistente");
            throw new ResponseEndException(htmlToReturn.Out(), Response, "1#KO - cartella sorgente dello zip non esistente");
        }
    }

    //'--ho finito e restituisco esito OK
    htmlToReturn.Write($@"1#OK");

}
@Html.Raw(htmlToReturn.Out())