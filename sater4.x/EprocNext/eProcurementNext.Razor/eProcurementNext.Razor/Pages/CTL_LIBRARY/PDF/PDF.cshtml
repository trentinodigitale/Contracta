@page "/CTL_LIBRARY/PDF/PDF.asp"
@using eProcurementNext.Application
@using eProcurementNext.CommonModule
@using Microsoft.VisualBasic
@using eProcurementNext.Razor.Pages.CTL_LIBRARY.DOCUMENT
@using eProcurementNext.Razor.Pages.CTL_LIBRARY.PDF;
@using eProcurementNext.Razor.Pages.CTL_LIBRARY.functions
@using static eProcurementNext.Razor.Pages.CTL_LIBRARY.functions.securityModel;
@model eProcurementNext.Razor.Pages.CTL_LIBRARY.PDF.PDFModel
@inject eProcurementNext.Session.ISession session;
@inject eProcurementNext.Application.IEprocNextApplication application;
@using static eProcurementNext.CommonModule.Basic;
@using static eProcurementNext.CommonModule.Const;
@using static eProcurementNext.CommonDB.Basic; 
@using static eProcurementNext.Razor.Pages.CTL_LIBRARY.DOCUMENT.print_documentModel;
@using static eProcurementNext.Razor.Pages.CTL_LIBRARY.DOCUMENT.CommonModel;
@using static eProcurementNext.Session.SessionMiddleware
@{
    LoadSession(HttpContext, session);
    EprocResponse response = new();
  



    //' ------------- PARAMETRI ------------
    //'
    //'  PDF_NAME      		 = nome (o prefisso) del file PDF che si vuole creare
    //'  URL             		 = Url che restituisce la stampa html
    //'  IDDOC           		 = ID del documento che si sta stampando
    //'  TYPEDOC         		 = Parametro che insieme a IDDOC identificano il documento
    //'  TO_SIGN         		 = Se YES si stà creando il PDF per essere firmato
    //'  TABLE_SIGN      		 = Tabella sulla quale andare a salvare l'hash del pdf
    //'  AREA_SIGN       		 = Prefisso della colonna nel quale salvare l'hash
    //'  IDENTITY_SIGN   		 = Colonna chiave primaria della tabella sulla quale salvare l'hash
    //'  IDDOCGEN        		 = id doc generico
    //'  LEGACY	      		 = yes, vecchia generazione pdf e firma. NO ( è il default)  nuova generazione
    //'  PAGESIZE		  		 = da A1 ad A10. Il default è A4
    //'  PAGEORIENTATION 		 = landscape o portrait. Il default è portrait
    //'  FITWITH		   		 = 0 o 1, YES or NO. Il default è SI
    //'  PDF_A		  		 = se YES si genererà un PDF/A-1b. Se viene passato TO_SIGN a yes il pdf-a sarà implicito
    //'  TO_SIGN_WITHOUT_PDFA	 = se YES non verrà prodotto il pdf-a anche se si è richiesta la firma con il parametro to_sign
    //'  SAVE_ATTACH			 = se YES salviamo il pdf generato in base dati. colonna SIGN_ATTACH (se presente parametro AREA_SIGN, sarà area + _sign_attach)
    //'  PROCESS				 = se avvalorato deve contenere il processo che si vuole che venga eseguito, composto nella forma DOCUMENT@@@SEND
    //'  FORCE_SIGN			 = se YES si forza il giro di firma, non veniamo bloccati se è già in corso una firma


    LoadSession(HttpContext, session);

    string idDoc = GetParamURL(Request.QueryString, "IDDOC");
    string TYPEDOC = GetParamURL(Request.QueryString, "TYPEDOC");


    validate("IDDOC", CStr(idDoc), TIPO_PARAMETRO_NUMERO, 0, "", 0, HttpContext, session);

    if (!string.IsNullOrEmpty(idDoc) && !string.IsNullOrEmpty(TYPEDOC)) // 
    { //'se non provengo da un documento generico

        //'-- Se sto facendo una chiamata al pdf in modalità backoffice non effettuo il salvataggio del documento

        if (CStr(GetParamURL(Request.QueryString, "backoffice")).ToUpper() != "YES")
        {
            objDoc = PrintDocument(session, response /*htmlToReturn*/, HttpContext, HttpContext.Response, HttpContext.Request);//PrintDocument ok

            objDoc.UpdateContentInMem(session, null);
            objDoc.Save(session);

            FreeMemDocumentNoAbandon(session);
        }
    }

    try
    {
        if (CStr(GetParamURL(Request.QueryString, "backoffice")).ToUpper() != "YES")
        {
            FreeMemDocumentNoAbandon(session);
        }
    }
    catch (Exception ex)
    {
      
        // se no ho chiamato il metodo sopra loggo l'errore
        if (CStr(GetParamURL(Request.QueryString, "backoffice")).ToUpper() != "YES")
        {
            TraceErr(ex, ApplicationCommon.Application.ConnectionString, "FreeMemDocumentNoAbandon");
        }
    }

    string strPathfile = "";
    string pdfName = "";

    //'--definisco queste variabili globali alla pagina valorizzate nella funzione generaPDF

    string mp_StrMsg_Process = "Errore";
    string mp_ICONMSG_Process = "2";

    ELAB_RET_CODE mp_vRetCode_Process = ELAB_RET_CODE.RET_CODE_OK;
    //string mp_vRetCode_Process = "0";

    int mp_show_error = 0;


    //'-- invoco la funzione di generazione e giro di firma (se richiesta) del pdf
    string esito = pdf_functionsModel.generaPDF(true, Request.QueryString, ref strPathfile, ref pdfName, HttpContext, session, ref mp_ICONMSG_Process, ref mp_StrMsg_Process, ref mp_vRetCode_Process, ref mp_show_error);
    //'response.write "TEST:" & esito
    //'response.end


    //'-- se la funzione generaPDF mi ha ritornato un errore
    if (!string.IsNullOrEmpty(esito))
    {
        //'call ShowError(esito)

        //'--se sono nel caso di processo e sono uscito con  'RET_CODE_BREAKANDCOMMIT = 3 'committ e fermo il processo
        //'--ricarico il documento chiamante
        if (mp_vRetCode_Process == ELAB_RET_CODE.RET_CODE_BREAKANDCOMMIT)
        {

            //'--per i nuovi documenti
            if (!string.IsNullOrEmpty(idDoc))   
            {

                string urlFinale = "../MessageBoxWin.asp?ML=yes&MSG=" + URLEncode(TruncateMessage(esito)) + "&CAPTION=" + mp_StrMsg_Process + "&ICO=" + mp_ICONMSG_Process;


                response.Write(@"<script language=""javascript"">");
                response.Write("try { self.opener.RefreshDocument('../document/'); } catch(err){}");
                response.Write("location.href = '" + Replace(Replace(urlFinale,@"\",@"\\"),"'","\'") + "';" );
                response.Write("</script>");
                throw new ResponseEndException(response.Out(), Response, "Pdf non generato perchè si è verificato un errore");
            }
        }

        if (mp_show_error == 0)
        {
            pdf_functionsModel.ShowError(esito, mp_StrMsg_Process, mp_ICONMSG_Process, Response);
        }
        else
        {
            pdf_functionsModel.ShowError_NO_ML(esito, "Errore", 2, Response);
        }

    }
    else
    {



        string strFile = "";
        if (!string.IsNullOrWhiteSpace(pdfName))
        {
            strFile = pdfName + ".pdf";
        }

        string applicazione = "";

        if (IsEmpty(application["NOMEAPPLICAZIONE"]) || string.IsNullOrWhiteSpace(CStr(application["NOMEAPPLICAZIONE"])))
        {
            applicazione = CStr(application["ApplicationName"]);
        }
        else
        {
            applicazione = CStr(application["NOMEAPPLICAZIONE"]);
        }

        //'-- conservo il nome del file pulito dal percorso
        string fileOriginal = System.IO.Path.GetFileName(strPathfile);

        //string[] fv = strPathfile.split("\\");
        //fileOriginal = fv( ubound(fv))

        //'session["FILE-PATH"] = strPathFile; --- non lo metto più in sessione perchè sembra esserci un limite fisico nella dimensione delle stringhe contenute in session

        string ip = net_utilsModel.getIpClient(Request);
        string ipServer = CStr(HttpContext.GetServerVariable("LOCAL_ADDR"));

        //'urlFinale = Application("WEBSERVERAPPLICAZIONE") & "/" & applicazione & "/ctl_library/pdf/pdf_stamp.asp?FILE-NAME=" & Server.URLEncode(strFile) & "&FILE-PATH=" & server.urlencode(fileOriginal) & "&anti_cache=" & Server.URLEncode(timestamp(now()) & Rnd)
        //'urlFinale = "./pdf_stamp.asp?FILE-NAME=" & Server.URLEncode(strFile) & "&FILE-PATH=" & server.urlencode(fileOriginal) & "&anti_cache=" & Server.URLEncode(timestamp(now()) & Rnd)
        //'urlFinale = "/" & applicazione & "/ctl_library/pdf/pdf_stamp.asp?FILE-NAME=" & Server.URLEncode(strFile) & "&FILE-PATH=" & server.urlencode(fileOriginal) & "&anti_cache=" & Server.URLEncode(timestamp(now()) & Rnd)

        //'-- ripristino la redirect utilizzando la SYS WEBSERVERAPPLICAZIONE ( la sys che contiene l'indirizzo pubblico ) perchè se il pdf viene generato dalla registrazione potremmo avere 2 indirizzi per application e per portale.
        //'-- se non facevamo la redirect in questo modo.. sulla 37 ( con erpriv erpub ) la generazione non funzionava provando a cercare la pagina pdf_stamp sull'indirizzo del chiamante del portale e non su quello dell'application.
        //'--	se dovessero nascere problemi di navigazione ip interno/ip esterno il problema è da imputare alla configurazione della SYS. va inserito un indirizzo utilizzabile sia da rete interna che da rete esterna.
        //'--	(come erpriv e erpub).
        //'-- Il problema in più da gestire è che se il server non può navigare utilizzando l'url pubblico. per gestire questo test l'ip del chiamante, se è l'ip deve essere il server l'indirizzo esterno lo svuoto

        //'-- se il chiamante è il server stesso
        string strIndirizzo = "";
        if (ip != "127.0.0.1" && ip != "::1" && ip != ipServer)
        {
            strIndirizzo = CStr(application["WEBSERVERAPPLICAZIONE"]);
        }
        else
        {
            strIndirizzo = "";
        }

        //'response.write ip
        //'response.write "<br/>"
        //'response.write Application("ip-backoffice")
        //'response.write "<br/>"
        //'response.write InStr(1,Application("ip-backoffice"),ip)
        //'response.write "<br/>"
        //'response.write strIndirizzo
        //'response.write "<br/>"
        //'response.write ipServer
        //'response.write "<br/>"
        //'response.end

        
        string urlFinale = strIndirizzo + "/" + applicazione + "/ctl_library/pdf/pdf_stamp.asp?FILE-NAME=" + URLEncode(strFile) + "&FILE-PATH=" + URLEncode(fileOriginal) + "&anti_cache=";//+ URLEncode(timestamp(DateTime.Now)); TODO

       

        //'response.write urlFinale
        //'response.end


        //'--faccio abandon se sessione utente vuota o -20
        //'--		commentato perchè la produzione del pdf lato portale è priva di idpfu e non deve fare session abandon
        //'if cstr(session("IdPfu")) = "" or  cstr(session("IdPfu")) = "-20" or cstr(session("IdPfu")) = "-10" then
        //'	session.abandon()
        //'end if


        string toSign = GetParamURL(Request.QueryString, "TO_SIGN");
        idDoc = GetParamURL(Request.QueryString,"IDDOC");
        string strActiveTabName = CStr(GetParamURL(Request.QueryString, "strActiveTabName"));
        string IDDOCGEN = GetParamURL(Request.QueryString, "IDDOCGEN");


        if (!string.IsNullOrEmpty(toSign) && (toSign.ToUpper() == "YES" || toSign == "1"))
        {

            //'-- se documento nuovo
            if (!string.IsNullOrEmpty(idDoc))
            {
                response.Write(@"<script language=""javascript"">");
                response.Write("try { self.opener.RefreshDocument('../document/'); } catch(err){}");
                response.Write("location.href = '" + Replace(Replace(urlFinale, "'", "\'"), @"\", @"\\") + "';");
                response.Write("</script>");
                throw new ResponseEndException(response.Out(), Response, "valore toSign");
            }
            else
            {
                //'da testare da contesti non bandocentrico (lato ente)
                response.Write(@"<script language=""javascript"">");
                response.Write(@"try { self.opener.location = '../../aflcommon/foldergeneric/OpenDoc.asp?lIdMsgPar=" + CStr(CLng(IDDOCGEN)) + "&strActiveTabName=" + Replace(strActiveTabName, "'", "\'") + "&Provenienza=INWORK'; } catch(err){}");
                response.Write("location.href = '" + Replace(Replace(urlFinale, "'", "\'"), @"\", @"\\") + "';");
                response.Write("</script>");
                throw new ResponseEndException(response.Out(), Response, "valore toSign");
            }

        }
        else
            throw new ResponseRedirectException(urlFinale, Response);
        }

    }

}