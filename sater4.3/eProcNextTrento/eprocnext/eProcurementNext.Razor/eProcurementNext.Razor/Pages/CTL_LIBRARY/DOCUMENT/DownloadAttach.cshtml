@page "/CTL_LIBRARY/DOCUMENT/DownloadAttach.asp"
@inject eProcurementNext.Session.ISession session;
@using eProcurementNext.CommonDB
@using eProcurementNext.CommonModule;
@using static eProcurementNext.CommonModule.Basic;
@using eProcurementNext.BizDB;
@using eProcurementNext.Core.Storage;
@using eProcurementNext.HTML;
@using eProcurementNext.Application;
@using Microsoft.Extensions.Primitives
@using Microsoft.VisualBasic;
@using System.Net;
@using eProcurementNext.Razor;
@using static eProcurementNext.Razor.Pages.CTL_LIBRARY.functions.securityModel
@using static eProcurementNext.Razor.Pages.CTL_LIBRARY.functions.DocumentPermissionModel
@using static eProcurementNext.Session.SessionMiddleware
@{
    CommonDbFunctions cdf = new();
    LoadSession(HttpContext, session);
    EprocResponse htmlToReturn = new();
}
@{
    var sqlParams = new Dictionary<string, object?>();
    //'-- se � presente la sys VIRTUALDIR_FIRME attiviamo il meccanismo di access guid per fare la redirect al pool dedicato
    string virtualDirectoryFirme = CStr(ApplicationCommon.Application["VIRTUALDIR_FIRME"]).Trim();

    if (!string.IsNullOrEmpty(virtualDirectoryFirme))
    {
        //'--------------------------------------------------------------------------------------------------------------------------------------
        //'-- GESTIONE SESSIONE CON ACCESS GUID  PER PERMETTERE LO SPOSTAMENTO DELLA DOWNLOADATTACH SOTTO UN POOL/VIRTUAL DIRECTORY DEDICATO ----
        //'--------------------------------------------------------------------------------------------------------------------------------------
        string accessGUID = GetParamURL(Request.QueryString.ToString(), "acckey");

        if (!string.IsNullOrEmpty(accessGUID))
        {  //'-- SE SIAMO GIA' NEL SECONDO GIRO, CIOE' NELLA PAGINA CON IL GUID GIA' PASSATO
           //'-- aggiungiamo buffer a true per risolvere l'errore "Buffering must be on.". questo perch� nella pagina facciamo un addHeader che in abinato alla redirect andava in errore
           //response.buffer = true;
            int accessGuidIdpfu = getAccessFromGuid(accessGUID);

            string strPermessiUtenti = "";
            //'--recupero stringa funzionalitautente da mettere in sessione
            sqlParams.Add("@accessGuidIdpfu", accessGuidIdpfu);
            string strSQL1 = "select pfuFunzionalita from ProfiliUtente with(nolock) where IdPfu = @accessGuidIdpfu";
            TSRecordSet rsUtenti = cdf.GetRSReadFromQuery_(strSQL1, ApplicationCommon.Application.ConnectionString, sqlParams);
            if (rsUtenti.RecordCount > 0)
            {
                rsUtenti.MoveFirst();
                strPermessiUtenti = CStr(rsUtenti["pfuFunzionalita"]);
            }
            //'response.write strPermessiUtenti
            //'response.end

            if (!string.IsNullOrEmpty(CStr(accessGuidIdpfu)) && CStr(accessGuidIdpfu) != "0")
            {
                session["IdPfu"] = CLng(accessGuidIdpfu);
                session["IdMP"] = 0;
                session["Funzionalita"] = strPermessiUtenti;
            }
            else
            {
                htmlToReturn.Write("accesso non valido o finestra temporale superata, ripetere l'operazione");
                throw new ResponseEndException(htmlToReturn.Out(), Response, "accesso non valido o finestra temporale superata, ripetere l'operazione");
            }
        }
        else
        {
            string accessGuid = insertAccessBarrier(session, HttpContext);

            //'-- EFFETTUO LA RICHIESTA DI GUID TEMPORIZZATO E FACCIO LA REDIRECT A ME STESSO CON L'AGGIUNTA DEL GUID
            string strPage = $"/{virtualDirectoryFirme}/CTL_LIBRARY/document/DownloadAttach.asp?acckey={URLEncode(accessGuid)}&" + GetQueryStringFromContext(Request.QueryString);

            //'response.write strPage
            throw new ResponseRedirectException(strPage, Response);
            //response.redirect strPage
            //response.end
            throw new ResponseEndException(htmlToReturn.Out(), Response, "");
        }
    }

    //'--controllo sicurezza sui parametri in input alla pagina

    //'function validate (nomeParametro, valoreDaValidare, tipoDaValidare, sottoTipoDaValidare, regExp, obblig )
    validate("DOCUMENT", GetParamURL(Request.QueryString.ToString(), "DOCUMENT"), TIPO_PARAMETRO_STRING, SOTTO_TIPO_PARAMETRO_TABLE, "", 0, HttpContext, session);
    //'--se dovesse arrivare -1 per qualche motivo, lo facciamo diventare 1 solo per fare il test, non utilizzo il tipo numerico perch� iddoc potrebbe anche essere "new" o simile
    validate("IDDOC", Replace(GetParamURL(Request.QueryString.ToString(), "IDDOC"), "-", ""), TIPO_PARAMETRO_STRING, SOTTO_TIPO_PARAMETRO_TABLE, "", 0, HttpContext, session);

    //'-- Parametro della sezione dettagli
    validate("SOURCE", GetParamURL(Request.QueryString.ToString(), "SOURCE"), TIPO_PARAMETRO_STRING, SOTTO_TIPO_PARAMETRO_TABLE, "", 0, HttpContext, session);

    //'-- Parametro url per extra attach
    //'call validate( "URL_EXTRA_ATTACH", request.querystring("URL_EXTRA_ATTACH") , TIPO_PARAMETRO_STRING, SOTTO_TIPO_PARAMETRO_PAROLASINGOLA, "", 0)

    //'--recupero parametri
    string[] aInfoSection;
    string listSection = string.Empty;
    string listSectionOK = string.Empty;
    string strSQL;
    string tmpBase = string.Empty;
    int Soglia_Allegati_Complessiva = 0;
    string strSQLAttach = string.Empty;
    string lIdPfu = CStr(session["IdPfu"]);

    string IDDOC = GetParamURL(Request.QueryString.ToString(), "IDDOC");
    string DOCUMENT = GetParamURL(Request.QueryString.ToString(), "DOCUMENT");
    string SOURCE = GetParamURL(Request.QueryString.ToString(), "SOURCE");
    string URL_EXTRA_ATTACH = GetParamURL(Request.QueryString.ToString(), "URL_EXTRA_ATTACH");

    //'--per il documento generico SOURCE=Sezione:area1;....;areaN ad es:Documentazione:griglia,Economica:griglia;economica
    //'--							� la lista delle sezioni con le varie aree
    //'--per i nuovi documenti     SOURCE=DOCUMENTAZIONE,OFFERTA,.... � la lista delle sezioni

    //'Response.Write  "IDDOC=" & IDDOC & "<br>DOCUMENT=" & DOCUMENT & "<br>SOURCE=" & SOURCE & "<br>URL_EXTRA_ATTACH=" & URL_EXTRA_ATTACH
    //'Response.End

    string DOCUMENT_CTL_DOC = string.Empty;
    string doc_table = string.Empty;

    if (string.IsNullOrEmpty(DOCUMENT) || DOCUMENT == "DOCUMENTO_GENERICO")
    {
        //'--si tratta di un documento generico
        //call BuildSqlAttach_GenericDocument
    }
    else
    {
        //'--VERIFICO SE E' CONSENTITO LO SCARICA ALLEGATI
        //'------------------------------------------------------------------------------------------------------------------------------
        //'--Commentato controllo in quanto con il download a blocchi di 10000 byte non ha pi� senso
        //'------------------------------------------------------------------------------------------------------------------------------
        if (SogliaAllegatiSuperata(IDDOC) != "YES")
        {
            //'-------------------------
            //'--DOCUMENTO CTL / NUOVI -
            //'-------------------------

            //'-- CONTROLLO QUALE DOCUMENT USARE
            //'-- se non esiste l'ID passato sulla CTL_DOC  uso il DOCUMENT in INPUT
            //'-- se invece esiste:
            //'-- controllo se esiste la relazione DOUNLOADATTACH.ASP
            //'-- 	se la relazione esiste uso quello indicato dalla relazione
            //'--     se la relazione NON esiste controllo se posso usare quello della CTL_DOC in questo modo:
            //'--     	posso usare il TIPODOC della CTL_DOC se � contenuto nei TIPIDOC restituiti dalla table/vista dei documenti che hanno doc_table = alla vista indicata sul documento (lib_documents)
            //'--			se non lo posso usare allora uso DOCUMENT in input

            //on error resume next
            //'-- sovrascrivo valore passato nel parametro document con il tipodoc presente in tabella relativo all'idDoc passato.
            sqlParams.Clear();
            sqlParams.Add("@IDDOC", CInt(IDDOC));
            strSQL = "select TipoDoc from CTL_DOC with(nolock) where id = @IDDOC";
            TSRecordSet rsTipoDoc = cdf.GetRSReadFromQuery_(strSQL, ApplicationCommon.Application.ConnectionString, sqlParams);

            if (rsTipoDoc.RecordCount > 0)
            {
                //'-- controllo se esiste la relazione DOUNLOADATTACH.ASP
                sqlParams.Clear();
                sqlParams.Add("@DOCUMENT", DOCUMENT);
                strSQL = "select REL_ValueOutput from CTL_Relations with(nolock) where REL_Type='DOWNLOADATTACH.ASP' and REL_ValueInput=@DOCUMENT";
                TSRecordSet rsRelTipoDoc = cdf.GetRSReadFromQuery_(strSQL, ApplicationCommon.Application.ConnectionString, sqlParams);
                if (rsRelTipoDoc.RecordCount > 0)
                {
                    //'--la relazione ESISTE ed uso quello indicatao dalla relazione
                    rsRelTipoDoc.MoveFirst();
                    DOCUMENT = CStr(rsRelTipoDoc["REL_ValueOutput"]);
                }
                else
                {
                    //'--la relazione NON ESISTE allora controllo se posso usare quello della CTL_DOC
                    //'--recupero la table/view usata sulla lib_documents per il tipodoc (DOCUMENT) in input
                    sqlParams.Clear();
                    sqlParams.Add("@DOCUMENT", DOCUMENT);
                    strSQL = "select DOC_Table from LIB_Documents with(nolock) where DOC_ID=@DOCUMENT";
                    TSRecordSet rsDocTable = cdf.GetRSReadFromQuery_(strSQL, ApplicationCommon.Application.ConnectionString, sqlParams);

                    if (rsDocTable.RecordCount > 0)
                    {
                        rsDocTable.MoveFirst();
                        doc_table = CStr(rsDocTable["DOC_Table"]);

                        rsTipoDoc.MoveFirst();

                        DOCUMENT_CTL_DOC = CStr(rsTipoDoc["TipoDoc"]);

                        if (doc_table.ToLower() == "ctl_doc")
                        {
                            //'--se e' proprio la ctl_doc allora sicuramente posso usare il tipodoc della ctl_doc
                            DOCUMENT = DOCUMENT_CTL_DOC;
                        }
                        else
                        {
                            //'--vedo se tra i documenti che usano questa doc_table c'� anche quello restituito dalla ctl_doc
                            sqlParams.Clear();
                            sqlParams.Add("@table", doc_table);
                            sqlParams.Add("@id", DOCUMENT_CTL_DOC);
                            strSQL = "select DOC_Table from LIB_Documents with(nolock) where DOC_Table=@table and DOC_ID=@id";
                            TSRecordSet rsTipiDocDoc_Table = cdf.GetRSReadFromQuery_(strSQL, ApplicationCommon.Application.ConnectionString, sqlParams);
                            if (rsTipiDocDoc_Table.RecordCount > 0)
                            {
                                DOCUMENT = DOCUMENT_CTL_DOC;
                            }
                        }
                    }
                }
            }
            //on error goto 0

            BuildSqlAttach_CtlDocument();
        }
        else
        {
            ShowError("Scarica Allegati disabilitato per soglia superata");
        }
    }

    //'Response.Write strSQLAttach
    //'Response.end
    DirectoryInfo? folderCurr = null;
    //'--se ci sono allegati da scaricare allora faccio lo zip
    if (!string.IsNullOrEmpty(strSQLAttach) || !string.IsNullOrEmpty(URL_EXTRA_ATTACH))
    {
        //on error resume next

        TSRecordSet? RsAttach;

        if (!string.IsNullOrEmpty(strSQLAttach))
        {
            RsAttach = cdf.GetRSReadFromQuery_(strSQLAttach, ApplicationCommon.Application.ConnectionString);
        }
        else
        {
            RsAttach = null;
        }

        if (!string.IsNullOrEmpty(strSQLAttach) || !string.IsNullOrEmpty(URL_EXTRA_ATTACH))
        {
            //'--Response.Write RsAttach.recordcount

            //'--leggere da configurazione path base
            tmpBase = CStr(ApplicationCommon.Application["PathFolderAllegati"]);

            string tmpCurr = $@"{tmpBase}{CommonStorage.GetTempName()}\";
            try
            {
                if (!CommonStorage.DirectoryExists(tmpCurr))
                {
                    folderCurr = CommonStorage.CreateDirectory(tmpCurr);
                    //'Response.Write(folderCurr.Attributes)
                }
            }
            catch
            {
                CommonStorage.DeleteDirectory(tmpCurr);
                ShowError("errore scarica allegati:contattare l'amministratore");
            }

            LibDbAttach objattach = new LibDbAttach();
            //set objattach=createobject("ctldb.lib_dbattach")
            //'Response.Write "tmpCurr=" & tmpCurr
            //'Response.End
            if (RsAttach is not null)
            {
                if (RsAttach.RecordCount > 0)
                {
                    RsAttach.MoveFirst();
                    while (!RsAttach.EOF)
                    {
                        try
                        {
                            string strSQLObj = string.Empty;
                            string tabellaUsata = string.Empty;
                            string idUsato = string.Empty;
                            //'--recupero il blob ed il nome file per id corrente
                            if (string.IsNullOrEmpty(DOCUMENT) || DOCUMENT == "DOCUMENTO_GENERICO")
                            {
                                sqlParams.Clear();
                                sqlParams.Add("@IdObj", CInt(RsAttach["IdObj"]!));
                                strSQLObj = " select objName as Nomefile, objFile as BlobFile from TAB_OBJ where IdObj=@IdObj";
                                tabellaUsata = "TAB_OBJ";
                                idUsato = "IdObj";
                            }
                            else
                            {
                                sqlParams.Clear();
                                sqlParams.Add("@ATT_Hash", CStr(RsAttach["ATT_Hash"]));
                                strSQLObj = " select Att_Name as Nomefile, Att_Obj as BlobFile from CTL_Attach with(nolock) where ATT_Hash=@ATT_Hash";
                                tabellaUsata = "CTL_Attach";
                                idUsato = "ATT_Hash";
                            }

                            //'response.write strSQLObj
                            TSRecordSet RsAttachBlob = cdf.GetRSReadFromQuery_(strSQLObj, ApplicationCommon.Application.ConnectionString, sqlParams);

                            //'--salvo il file sul disco in una cartella temporanea
                            string nomefile = CStr(RsAttachBlob["Nomefile"]);

                            //'--se esiste un file con lo stesso nome aggiungo un contatore prima dell'estensione
                            nomefile = CheckEsitenza_RenameFileAllegato(nomefile, tmpCurr);

                            //'SaveBinaryData tmpCurr & nomefile , RsAttachBlob("BlobFile")

                            eProcurementNext.CommonDB.Basic.saveFileFromRecordSet("Att_Obj", tabellaUsata, idUsato, CStr(RsAttach.Fields[idUsato]), CStr(tmpCurr + nomefile));

                            //objattach.saveFileFromRecordSet_FromASP(RsAttachBlob.Fields["BlobFile"], clng(RsAttachBlob.Fields["BlobFile"].ActualSize), cstr(tmpCurr + nomefile));


                            //'Response.Write err.Description & "-" & err.number
                            //'Response.End

                            //set RsAttachBlob=nothing

                            RsAttach.MoveNext();
                        }
                        catch
                        {
                            if (folderCurr != null)
                            {
                                folderCurr.Delete();
                            }
                            ShowError("errore scarica allegati");
                        }
                    }
                }
            }

            //'Response.End

            //'--prima di creare lo zip vedo se devo aggiungere altri allegati
            //'--alla cartella da comprimere
            if (!string.IsNullOrEmpty(URL_EXTRA_ATTACH))
            {
                //'--aggiungo come parametro il nome della cartella in cui aggiungere i file
                //'URL_EXTRA_ATTACH = URL_EXTRA_ATTACH & "&FOLDER=" & tmpCurr

                session["TEMP_FOLDER_DOWNLOAD"] = tmpCurr;

                string[] ainfoUrl = Strings.Split(URL_EXTRA_ATTACH, ",");

                string pagineAmmesse = CStr(ApplicationCommon.Application["SECURITY_WHITELIST_ATTACH"]);

                for (int k = 0; k <= ainfoUrl.Length - 1; k++)
                {
                    if (!string.IsNullOrEmpty(pagineAmmesse))
                    {
                        string pagToInvoke = Replace(ainfoUrl[k], @"..", @"");
                        pagToInvoke = Replace(pagToInvoke, @"/", @"");
                        pagToInvoke = $"@@@{pagToInvoke.ToLower()}@@@";

                        if (!pagineAmmesse.ToLower().Contains(pagToInvoke.ToLower(), StringComparison.Ordinal))
                        {
                            //on error resume next
                            try
                            {
                                if (folderCurr is not null)
                                {
                                    folderCurr.Delete();
                                }
                            }
                            catch
                            {

                            }
                            ShowError("Pagina EXTRA_ATTACH richiesta non valida");
                        }
                    }
                    string ipServer = HttpContext.GetServerVariable("LOCAL_ADDR")!;
                    string strSite = string.Empty;

                    #if DEBUG
                        ipServer = Request.Host.ToString();
                    #endif

                    if (string.IsNullOrEmpty(ApplicationCommon.Application["WEBSERVERAPPLICAZIONE_INTERNO"]))
                    {
                        strSite = "http://";
                        if (HttpContext.GetServerVariable("SERVER_PORT_SECURE") == "1")
                        {
                            strSite = "https://";
                        }

                        strSite += ipServer;
                    }
                    else
                    {
                        strSite = ApplicationCommon.Application["WEBSERVERAPPLICAZIONE_INTERNO"]!;
                    }

                    

                    string path = strSite + "/" + ApplicationCommon.Application["NOMEAPPLICAZIONE"] + "/CTL_LIBRARY/DOCUMENT/" + ainfoUrl[k] + "?" + GetQueryStringFromContext(Request.QueryString);

                    //'--PER I NUOVI DOCUMENTI ESCLUDO LE PAGINE RETTIFICA,REVOCA e PROROGA PERCHE' GLI HASH SONO STATI RECUPEARTI DALLA VISTA DOWNLOAD_ATTACH_LISTA_ALLEGATI_EXTRA
                    if (!string.IsNullOrEmpty(DOCUMENT) && DOCUMENT != "DOCUMENTO_GENERICO")
                    {
                        if (
                            !ainfoUrl[k].ToLower().Contains(("/Report/avvisi_di_revoca.asp").ToLower(), StringComparison.Ordinal) &&
                            !ainfoUrl[k].ToLower().Contains(("/Report/avvisi_di_proroga.asp").ToLower(), StringComparison.Ordinal) &&
                            !ainfoUrl[k].ToLower().Contains(("/Report/avvisi_di_rettifica.asp").ToLower(), StringComparison.Ordinal)
                            )
                        {
                            ServerExecute(path, session, Request);
                        }
                    }
                    else
                    {
                        ServerExecute(path, session, Request);
                    }
                }
            }

            string strFilePath = "";

            try
            {
                int numFiles = CommonStorage.ListObjects(tmpCurr).Count;

                if (numFiles > 0)
                {
                    //' Creo l'oggetto Zip
                    Zip objZip = new Zip();

                    ////' Eseguo la prima operazione di compressione..
                    ////' ..e contestualmente creo l'archivio
                    string tempNameZip = CommonStorage.GetTempName();

                    objZip.Pack(tmpCurr, tmpBase + tempNameZip + "_ALLEGATIDOCUMENTO" + IDDOC + "" + session["idPfu"] + ".zip");

                    ////'--cancello la cartella Temporanea dove avevo salvato gli attach
                    CommonStorage.DeleteDirectory(tmpCurr);

                    strFilePath = tmpBase + tempNameZip + "_ALLEGATIDOCUMENTO" + IDDOC + "" + session["idPfu"] + ".zip";

                    ////'Response.ContentType = "application/zip"
                    Response.Headers.TryAdd("Content-Disposition", "attachment; filename=AllegatiDocumento.zip");

                    //LETTURA FILE in "chunk" e scrittura sul body della response
                    using (FileStream objStream = new FileStream(strFilePath, FileMode.Open, FileAccess.Read))
                    {
                        byte[] b = new byte[1024];
                        int len;
                        int counter = 0;
                        while (true)
                        {
                            len = objStream.Read(b, 0, b.Length);
                            byte[] c = new byte[len];
                            b.Take(len).ToArray().CopyTo(c, 0);
                            htmlToReturn.BinaryWrite(HttpContext, c);
                            if (len == 0 || len < 1024)
                            {
                                break;
                            }
                            counter++;
                        }

                        //objStream.Close();
                    }
                    //' cancello file zip vecchi se presenti
                    CommonStorage.DeleteFile(strFilePath);
                }
                else
                {
                    ShowError("Siccome non sono presenti allegati non e' possibile creare il file Zip");                    
                }
            }
            catch (Exception ex) when (ex is not ResponseEndException)
            {
                string descError = ex.Message;

                //'-- Scriviamo l'errore nell'event viewer

                eProcurementNext.CommonDB.Basic.TraceErr(ex, ApplicationCommon.Application.ConnectionString, descError);

                //'--provo a cancellare lo zip creato

                if (CommonStorage.FileExists(strFilePath))
                {
                    CommonStorage.DeleteFile(strFilePath);
                }

                ShowError("errore scarica allegati");
            }
        }
        else
        {
            ShowError("non ci sono allegati per il documento");
        }
    }
    else
    {
        ShowError("non ci sono allegati per il documento");
    }

    //'--faccio abandon se sessione utente vuota o -20
    if (string.IsNullOrEmpty(CStr(session["IdPfu"])) || CStr(session["IdPfu"]) == "-20" || CStr(session["IdPfu"]) == "-10")
    {
        MainGlobalAsa.SessionAbandon(session);
    }

    //'--sub per salvare gli allegati sul disco
    void SaveBinaryData(dynamic FileName, dynamic fld)
    {
        throw new NotImplementedException("metodo non usato");
    }

    void ShowError(string ErrText)
    {
        //'Response.Redirect "../MessageBoxWin.asp?ML=yes&MSG=" & ErrText & "&CAPTION=Errore&ICO=2"
        htmlToReturn.Write($@"

	        <script src=""../jscript/ExecFunction.js"" ></script>
	        <script language=""javascript"">
	        var Left = (screen.availWidth-w)/2;
	        var Top  = (screen.availHeight-h)/2;
	        var w = 400;
	        var h = 300;
	        var strPosition = ',left=' + Left + ',top=' + Top + ',width=' + w + ',height=' + h ;

	        //apro pop-up per messaggio errore
	        ExecFunction( '../MessageBoxWin.asp?ML=yes&MSG=" + URLEncode(TruncateMessage(ErrText)) + $@"&CAPTION=Errore&ICO=2' , 'MSGBOX' , strPosition );

	        try {{
		        self.close();
		        }}
	        catch(e){{}}

	        </script>

	    ");
        throw new ResponseEndException(htmlToReturn.Out(), Response, "ShowError");
        //response.end
    }

    //'--costruisce la quesry degli attach da scaricare per un documento generico
    void BuildSqlAttach_GenericDocument()
    {
        throw new NotImplementedException("documento generico");
    }

    void BuildSqlAttach_CtlDocument()
    {
        //'on error resume }

        //'--si tratta di un nuovo documento
        string strFOLDER;
        //dim MappaFolderVincoli
        Dictionary<string, string> MappaFolderVincoli = new Dictionary<string, string>();

        //dim MappaFolderSezioni
        Dictionary<string, string> MappaFolderSezioni = new Dictionary<string, string>();

        strFOLDER = "";

        //'--controllo permesso apertura documento solo se sono in sessione
        if (!string.IsNullOrEmpty(lIdPfu) && lIdPfu != "-20")
        {
            DocPermission(HttpContext, GetParamURL(Request.QueryString.ToString(), "IDDOC"), DOCUMENT, CStr(GetParamURL(Request.QueryString.ToString(), "PARAM")), session, htmlToReturn, Request, Response);
        }

        //'--recupero le sezioni passate in input
        if (!string.IsNullOrEmpty(SOURCE))
        {
            listSection = "," + SOURCE + ",";
        }
        //'Response.Write listSection
        //'Response.End

        //'--recupero sezioni del documento
        strSQL = "select " +
                    " dbo.GetValue('FOLDER',convert(varchar(MAX),DOC_Param)) as Folder,DS.DSE_ID as Sezione,DSE_MOD_ID as Modello,DES_Table as Tabella," +
                    " dbo.GetValue('VIEW',convert(varchar(MAX),DSE_PARAM)) as Vista, " +
                    " dbo.GetValue('FILTER_ROW',convert(varchar(MAX),DSE_PARAM)) as FilterRow, " +
                    " DES_FieldIdDoc as FieldIdDoc, " +
                    " dbo.GetValue('DYNAMIC_MODEL',convert(varchar(MAX),DSE_PARAM)) as Dynamic_Model, " +
                    " dbo.GetValue('WRITE_VERTICAL',convert(varchar(MAX),DSE_PARAM)) as WRITE_VERTICAL, " +
                    " isnull(CM.MOD_Name,'') as ModelloDinamico, " +
                    " isnull(DES_PosPermission,0) as DES_PosPermission " +
                 " from " +
                    " lib_documents inner join LIB_DocumentSections DS on DSE_DOC_ID=DOC_ID" +
                    " left outer join CTL_DOC_SECTION_MODEL CM on CM.IdHeader=" + IDDOC + " and CM.DSE_ID=DS.DSE_ID " +
                 " where " +
                    " DSE_DOC_ID=DOC_ID and DSE_DOC_ID='" + DOCUMENT + "' " +
                    " and des_progid not in ('CtlDocument.Sec_Static','CtlDocument.Sec_Total') " +
                 " order by des_order ";


        //'response.write strSQL
        //'response.end

        TSRecordSet rsSezioni = cdf.GetRSReadFromQuery_(strSQL, ApplicationCommon.Application.ConnectionString);
        //'response.write "Permessi=" & session("Funzionalita") & "<br>"

        if (rsSezioni.RecordCount > 0)
        {


            rsSezioni.MoveFirst();

            //'--se ci sono configurati i folder e non sono fuori sessione verifico eventuali vincoli da superare
            if (!string.IsNullOrEmpty(CStr(rsSezioni.Fields["FOLDER"])) && !string.IsNullOrEmpty(lIdPfu) && lIdPfu != "-20")
            {

                //'--verifico se per qualche folder (composto da n sezioni) esiste una stored per verificare i vincoli
                //'--sulle sezioni

                strFOLDER = CStr(rsSezioni.Fields["FOLDER"]);
                string[] aInfoFolder = Strings.Split(strFOLDER, "~");

                for (int i = 0; i <= aInfoFolder.Length - 1; i++)
                {// to ubound(aInfoFolder)

                    string[] aInfoVincoli = Strings.Split(aInfoFolder[i], ":");

                    //'--se esiste una stored di controllo
                    if ((aInfoVincoli.Length - 1) == 1)
                    {

                        //'--ciclo sulle sezioni del folder
                        aInfoSection = Strings.Split(aInfoVincoli[0], ",");

                        //'--mappa etichetta folder - stored vincolo
                        if (!MappaFolderVincoli.ContainsKey(aInfoSection[0]))
                        {
                            MappaFolderVincoli.Add(aInfoSection[0], aInfoVincoli[1]);
                        }

                        string strListSectionFolder = "";

                        for (int k = 3; k <= aInfoSection.Length - 1; k++)
                        {// to ubound(aInfoSection)


                            if (!string.IsNullOrEmpty(aInfoSection[k]) && (string.IsNullOrEmpty(SOURCE) || listSection.ToUpper().Contains("," + aInfoSection[k] + ",", StringComparison.Ordinal)))
                            {

                                int nPermission = 1;

                                //'--se settato un PERMESSO sulla sezione per essere visualizzata l'utente deve avere il permesso
                                rsSezioni.Filter("Sezione='" + aInfoSection[k] + "'");


                                if (rsSezioni.RecordCount > 0)
                                {

                                    if (CStr(rsSezioni.Fields["DES_PosPermission"]) != "0")
                                    {
                                        if (Strings.Mid(session["Funzionalita"], CInt(rsSezioni.Fields["DES_PosPermission"]), 1) == "0")
                                        {
                                            nPermission = 0;
                                        }
                                    }

                                }

                                //'response.write "sezione = " & aInfoSection(k) & " - permesso=" & rsSezioni("DES_PosPermission").value & " - abilitato =" & nPermission & "<br>"

                                rsSezioni.Filter("");

                                if (nPermission == 1)
                                {

                                    //'--lista delle sezioni visualizzate
                                    if (string.IsNullOrEmpty(listSectionOK))
                                    {
                                        listSectionOK = aInfoSection[k];
                                    }
                                    else
                                    {
                                        listSectionOK = listSectionOK + "," + aInfoSection[k];
                                    }

                                    //'--lista sezioni del folder
                                    if (string.IsNullOrEmpty(strListSectionFolder))
                                    {
                                        strListSectionFolder = aInfoSection[k];
                                    }
                                    else
                                    {
                                        strListSectionFolder = strListSectionFolder + "," + aInfoSection[k];
                                    }

                                }

                            }
                        }

                        if (!string.IsNullOrEmpty(strListSectionFolder))
                        {
                            //'--conservo la lista delle sezioni per ogni folder
                            if (!MappaFolderSezioni.ContainsKey(aInfoSection[0]))
                            {
                                MappaFolderSezioni.Add(aInfoSection[0], strListSectionFolder);
                            }

                        }

                        //'listSectionOK = "," & listSectionOK & ","


                    }
                    else
                    {

                        aInfoSection = Strings.Split(aInfoFolder[i], ",");


                        for (int k = 3; k <= aInfoSection.Length - 1; k++)
                        {// to ubound(aInfoSection)
                         //'Includo la sezione se richiesta dal SOURCE o richieste tutte
                            if (string.IsNullOrEmpty(SOURCE) || listSection.ToUpper().Contains("," + aInfoSection[k] + ",", StringComparison.Ordinal))
                            {

                                if (string.IsNullOrEmpty(listSectionOK))
                                {
                                    listSectionOK = aInfoSection[k];
                                }
                                else
                                {
                                    listSectionOK = listSectionOK + "," + aInfoSection[k];
                                }

                            }
                        }


                    }

                }

            }
            else
            {

                if (!string.IsNullOrEmpty(SOURCE))
                {

                    //'--sono esattamente quelle passate in input
                    listSectionOK = listSection;

                }
                else
                {

                    //'--	lista di tutte le sezioni del documento
                    while (!rsSezioni.EOF)
                    {

                        if (string.IsNullOrEmpty(listSectionOK))
                        {
                            listSectionOK = CStr(rsSezioni.Fields["Sezione"]);
                        }
                        else
                        {
                            listSectionOK = listSectionOK + "," + CStr(rsSezioni.Fields["Sezione"]);
                        }

                        rsSezioni.MoveNext();

                    }

                    //'listSectionOK = "," & listSectionOK & ","

                }

            }



        }
        else
        {
            ShowError("Errore durante il recupero sezioni del documento, ripetere l'operazione");
        }

        //'Aggiungo carattere virgola inizio e fine se non presente
        if (!string.IsNullOrEmpty(listSectionOK) && Strings.Left(listSectionOK, 1) != ",")
        {
            listSectionOK = "," + listSectionOK + ",";
        }

        //'response.write listSectionOK
        //'response.end

        //'--verifico per ogni sezione se soggetto a vincolo
        Dictionary<string, string> MappaStoredVerificate;
        string EsitoVerifica;

        if (MappaFolderVincoli.Count > 0)
        {

            //set MappaStoredVerificate = createobject("scripting.dictionary")
            MappaStoredVerificate = new Dictionary<string, string>();
            var aStored = MappaFolderVincoli.Values.ToList();//.Insert(0, "--");
                                                             //aStored.Insert(0, "--");
            var aSection = MappaFolderVincoli.Keys.ToList();//.Insert(0, "--");
                                                            //aSection.Insert(0, "--");

            //'--per ogni sezione soggetta a controllo
            for (int i = 0; i <= MappaFolderVincoli.Count - 1; i++)
            {//  to MappaFolderVincoli.Count-1

                EsitoVerifica = "OK";
                string strStored = aStored[i];
                string strSection = aSection[i];
                string strDescBlocco = "";
                //'Response.Write strStored & "-" & strSection & "<br>"
                //'Response.end

                //'--se la stored non � ancora stata verificata la verifico
                //'if not MappaStoredVerificate.exists(strStored) ) {

                //'--effettuo la chiamata alla stored
                string strSQLVincoli = " exec " + strStored + " '" + strSection + "','" + IDDOC + "','" + lIdPfu + "'";

                //'Response.Write strSQLVincoli & "<br>"
                //'Response.End

                //RsVincoli = nothing
                TSRecordSet RsVincoli = cdf.GetRSReadFromQuery_(strSQLVincoli, ApplicationCommon.Application.ConnectionString);


                if (RsVincoli.RecordCount > 0)
                {

                    RsVincoli.MoveFirst();

                    if (!string.IsNullOrEmpty(CStr(RsVincoli.Fields["Blocco"])))
                    {

                        string esitoVincolo = CStr(RsVincoli.Fields["Blocco"]);
                        strDescBlocco = esitoVincolo;
                        string[] ainfoesito = Strings.Split(esitoVincolo, "~");


                        if (Strings.Left(esitoVincolo, 8) == "CAPTION:")
                        {

                            if (ainfoesito.Length - 1 > 0)
                            {
                                strDescBlocco = ainfoesito[1];
                            }
                            else
                            {
                                strDescBlocco = "";
                            }
                        }

                        if (!string.IsNullOrEmpty(strDescBlocco))
                        {
                            EsitoVerifica = "KO";
                        }

                    }

                }


                //'--aggiungo alla mappa delle stored verificate
                //'	MappaStoredVerificate.Add strStored,EsitoVerifica

                //'} else {
                //'	EsitoVerifica = MappaStoredVerificate(strStored)
                //'}

                //'--se i vincoli non sono superati la sezione non pu essere aperta e la tolgo da quelle OK
                if (EsitoVerifica == "KO")
                {

                    //'--recupero la lista delle sezioni dal folder
                    try
                    {
                        string listSectionFolder = MappaFolderSezioni[strSection];

                        listSectionOK = listSectionOK.Replace("," + listSectionFolder + ",", ",");
                    }
                    catch
                    {

                    }
                }

                //'Response.Write strStored & "-" & strSection & "<br>"


            }


        }

        //'Response.write listSectionOK
        //'response.end

        if (listSectionOK != "," && !string.IsNullOrEmpty(listSectionOK))
        {

            if (Strings.Left(listSectionOK, 1) == ",")
            {
                listSectionOK = Strings.Mid(listSectionOK, 2, listSectionOK.Length - 2);
            }

            //'--per ogni sezione considerando la colonna DES_FieldIdDoc e la tabella o la VIEW
            //'--e tenendo conto del parametro FILTER_ROW
            //'--mi prendo il modello associato e se tra gli attributi ci sono attributi di tipo attach
            //'--mi devo recuperare gli obj per tutti gli allegati
            //'--(del valore dell'attach mi colleziona solo l'hash per andare sulla ctl_attach)

            string[] aInfoSectionOk = Strings.Split(listSectionOK, ",");
            string strHashAttach = "";

            //'--per ogni sezione da considerare
            for (int i = 0; i <= aInfoSectionOk.Length - 1; i++)
            {//to ubound(aInfoSectionOk)

                rsSezioni.Filter("Sezione='" + aInfoSectionOk[i] + "'");
                //'response.write aInfoSectionOk(i)
                if (!rsSezioni.EOF)
                {

                    //'if ucase(rsSezioni("WRITE_VERTICAL").value) <> "YES" ) {

                    string strTable = CStr(rsSezioni.Fields["Tabella"]);

                    //'--se presente la vista considero la vista
                    if (!string.IsNullOrEmpty(CStr(rsSezioni.Fields["Vista"])))
                    {
                        strTable = CStr(rsSezioni.Fields["Vista"]);
                    }

                    string strModello = CStr(rsSezioni.Fields["Modello"]);

                    //'--se dinamico recupero il modello diversamente
                    if (CStr(rsSezioni.Fields["Dynamic_Model"]).ToLower() == "yes")
                    {
                        strModello = CStr(rsSezioni.Fields["ModelloDinamico"]);
                    }

                    string strFieldIdDoc = CStr(rsSezioni.Fields["FieldIdDoc"]);
                    string strFilterRow = "";
                    strFilterRow = CStr(rsSezioni.Fields["FilterRow"]);

                    if (!string.IsNullOrEmpty(strModello))
                    {

                        string strAttribAttach = "";

                        //'--recupero dal modello gli attributi attach

                        //'response.write strModello
                        //'response.write


                        //'--prova a recuperare il modello dalle nuove tabelle ctl_model..
                        string strSQLDiz = "select dzt_name from CTL_ModelAttributes,lib_dictionary d where ma_mod_id='" + strModello + "' and ma_dzt_name=d.dzt_name and d.dzt_type=18";
                        TSRecordSet RsDiz = cdf.GetRSReadFromQuery_(strSQLDiz, ApplicationCommon.Application.ConnectionString);

                        if (RsDiz.RecordCount == 0)
                        {

                            //'--se non presnte recupero il modello dalle tabelle classiche
                            strSQLDiz = "select dzt_name from LIB_ModelAttributes,lib_dictionary where ma_mod_id='" + strModello + "' and ma_dzt_name=dzt_name and dzt_type=18";
                        }


                        //'Response.Write strSQLDiz & "<br>"
                        //'Response.End

                        RsDiz = cdf.GetRSReadFromQuery_(strSQLDiz, ApplicationCommon.Application.ConnectionString);

                        if (RsDiz.RecordCount > 0)
                        {

                            RsDiz.MoveFirst();
                            while (!RsDiz.EOF)
                            {

                                if (string.IsNullOrEmpty(strAttribAttach))
                                {
                                    strAttribAttach = CStr(RsDiz.Fields["dzt_name"]);
                                }
                                else
                                {
                                    strAttribAttach = strAttribAttach + "," + RsDiz.Fields["dzt_name"];
                                }

                                RsDiz.MoveNext();
                            }
                            string strSQLHash;
                            //'--effettuo query per recuperare hash degli allegati
                            if (CStr(rsSezioni.Fields["WRITE_VERTICAL"]) != "YES")
                            {
                                strSQLHash = " select " + strAttribAttach + " from " + strTable + " where " + strFieldIdDoc + "=" + IDDOC;
                            }
                            else
                            {
                                strSQLHash = " select value from " + strTable + " where " + strFieldIdDoc + "=" + IDDOC + " and dzt_name='" + strAttribAttach + "'";
                            }


                            //'Response.Write strSQLHash & "<br>"

                            if (!string.IsNullOrEmpty(strFilterRow))
                            {
                                strSQLHash = strSQLHash + " and " + strFilterRow;
                            }


                            //'Response.Write strSQLHash & "<br>"
                            //'Response.End

                            TSRecordSet? RsHashAttach = null;
                            try
                            {
                                RsHashAttach = cdf.GetRSReadFromQuery_(strSQLHash, ApplicationCommon.Application.ConnectionString);
                            }
                            catch
                            {
                                RsHashAttach = null;
                            }
                            if (RsHashAttach != null)
                            {
                                if (RsHashAttach.RecordCount > 0)
                                {

                                    RsHashAttach.MoveFirst();
                                    while (!RsHashAttach.EOF)
                                    {

                                        for (int z = 0; z <= RsHashAttach.Columns.Count - 1; z++)
                                        {// To RsHashAttach.Fields.Count - 1

                                            if (CStr(RsHashAttach.Fields[z]) != "")
                                            {

                                                int bAddAttach = 0;


                                                string strValueAttach = CStr(RsHashAttach.Fields[z]);

                                                //'--effettuo la split su *** perch� pu� essere multivalore
                                                string[] aMultiAttach = Strings.Split(strValueAttach, "***");

                                                for (int t = 0; t <= aMultiAttach.Length - 1; t++)
                                                {// to ubound (aMultiAttach)

                                                    //'--prendo solo la 3 posizione che contiene l'hash dell'allegato
                                                    string[] aInfoHash = Strings.Split(aMultiAttach[t], "*");

                                                    if (string.IsNullOrEmpty(strHashAttach))
                                                    {

                                                        strHashAttach = "'" + aInfoHash[3] + "'";
                                                        bAddAttach = 1;
                                                    }
                                                    else
                                                    {

                                                        //'--se non presente lo aggiungo
                                                        if (Strings.InStr("," + strHashAttach + ",", ",'" + aInfoHash[3] + "',") == 0)
                                                        {
                                                            strHashAttach = strHashAttach + ",'" + aInfoHash[3] + "'";
                                                            bAddAttach = 1;
                                                        }

                                                    }

                                                    if (IsNumeric(aInfoHash[2]) && bAddAttach == 1)
                                                    {
                                                        Soglia_Allegati_Complessiva = CInt(CDbl(Soglia_Allegati_Complessiva) + CDbl(aInfoHash[2]));
                                                    }

                                                }

                                            }
                                        }

                                        RsHashAttach.MoveNext();
                                    }

                                }
                            }
                        }

                    }

                    //'}

                }

                rsSezioni.Filter("");

            }

            //'response.write strHashAttach & "<br>"
            //'response.end

            //'--considero gli allegati aggiunti deo documento interrognado la vista DOWNLOAD_ATTACH_LISTA_ALLEGATI_EXTRA
            string strSQLAttachExtra = "select allegato from DOWNLOAD_ATTACH_LISTA_ALLEGATI_EXTRA where Tipodoc = '" + DOCUMENT.Replace("'", "''") + "' and id=" + IDDOC;
            TSRecordSet RsAttachExtra = cdf.GetRSReadFromQuery_(strSQLAttachExtra, ApplicationCommon.Application.ConnectionString);
            if (RsAttachExtra != null)
            {

                if (RsAttachExtra.RecordCount > 0)
                {

                    RsAttachExtra.MoveFirst();

                    while (!RsAttachExtra.EOF)
                    {


                        int bAddAttach = 0;

                        string strValueAttach = CStr(RsAttachExtra.Fields["allegato"]);

                        //'--effettuo la split su *** perch� pu� essere multivalore
                        string[] aMultiAttach = Strings.Split(strValueAttach, "***");

                        for (int t = 0; t <= aMultiAttach.Length - 1; t++)
                        {// to ubound (aMultiAttach)

                            string[] aInfoHash = Strings.Split(aMultiAttach[t], "*");

                            if (string.IsNullOrEmpty(strHashAttach))
                            {
                                strHashAttach = "'" + aInfoHash[3] + "'";
                                bAddAttach = 1;
                            }
                            else
                            {
                                if (Strings.InStr("," + strHashAttach + ",", ",'" + aInfoHash[3] + "',") == 0)
                                {
                                    strHashAttach = strHashAttach + ",'" + aInfoHash[3] + "'";
                                    bAddAttach = 1;
                                }
                            }

                            if (IsNumeric(aInfoHash[2]) && bAddAttach == 1)
                            {
                                Soglia_Allegati_Complessiva = CInt(CDbl(Soglia_Allegati_Complessiva) + CDbl(aInfoHash[2]));
                            }

                        }

                        RsAttachExtra.MoveNext();

                    }

                }

            }

            //'response.write strHashAttach & "<br>"
            //'response.write Soglia_Allegati_Complessiva
            //'response.end


            //'--costruisco la query per recuperare i blob degli attach
            if (!string.IsNullOrEmpty(strHashAttach))
            {
                //'strSQLAttach = "select Att_Name as Nomefile,Att_Obj as BlobFile from ctl_attach where att_hash in (" & strHashAttach & ")"
                strSQLAttach = "select distinct att_hash from ctl_attach with(nolock) where att_hash in (" + strHashAttach + ")  and isnull(att_cifrato,0)=0 ";

                //'--se sono fuori sessione considero solo gli allegati pubblici
                if (string.IsNullOrEmpty(lIdPfu) || CStr(lIdPfu) == "-20")
                {
                    strSQLAttach = strSQLAttach + " and isnull(ATT_Pubblico,0)=1";
                }

                //'Response.Write strSQLAttach
                //'Response.end

                //'--controllo se la taglia complessiva degli allegati supera la soglia massima consentita
                dynamic MAX_SOGLIA_ALLEGATI = Get_Func_Property("DOWNLOADATTACH.ASP", "MAX_SOGLIA_ALLEGATI", "DEFAULTVALUE", "200", "-1");


                //'response.write cdbl(MAX_SOGLIA_ALLEGATI) * 1024.0 * 1024.0 & "<br>"
                //'response.write Soglia_Allegati_Complessiva
                //'response.end

                //'--se la size complessiva supera la soglia segno la cosa sul documento
                //'------------------------------------------------------------------------------------------------------------------------------
                //'--commentata perch� con il download a blocchi di 10000 byte dello zip finale non ha pi� senso ilcontrollo sulla taglia
                //'------------------------------------------------------------------------------------------------------------------------------
                if (Soglia_Allegati_Complessiva > CDbl(MAX_SOGLIA_ALLEGATI) * 1024.0 * 1024.0)
                {

                    string strSQLFlagSoglia = "if not exists (select * from ctl_doc_value with (nolock) where idheader=" + IDDOC + " and dse_id='SOGLIA_ALLEGATI' and dzt_name='MAX_SOGLIA_ALLEGATI_SUPERATA' )" +
                                        "begin" +
                                        "	insert into ctl_doc_value " +
                                        "	(IdHeader, DSE_ID, Row, DZT_Name, Value)" +
                                        "	values" +
                                        "	(" + IDDOC + " , 'SOGLIA_ALLEGATI', 0, 'MAX_SOGLIA_ALLEGATI_SUPERATA', 'YES')" +
                                        "end";

                    //'response.write strSQLFlagSoglia
                    //'response.end

                    cdf.Execute(strSQLFlagSoglia, ApplicationCommon.Application.ConnectionString);

                    //'--restituisco messaggio a video scarica allegati non consentito
                    ShowError("Scarica Allegati disabilitato per soglia superata");
                }

                //'--controllo se tutti gli allegati sono cifrati
                string strSQLAttachCifrati;
                strSQLAttachCifrati = "select distinct att_hash from ctl_attach with(nolock) where att_hash in (" + strHashAttach + ")  and isnull(att_cifrato,0)=1 ";
                TSRecordSet RsAttachCifrati = cdf.GetRSReadFromQuery_(strSQLAttachCifrati, ApplicationCommon.Application.ConnectionString);
                if (RsAttachCifrati is not null)
                {
                    if (RsAttachCifrati.RecordCount > 0)
                    {
                        //'--restituisco messaggio a video scarica allegati non consentito
                        ShowError("Non tutti gli allegati richiesti sono disponibili decifratura in corso");
                    }
                }
            }
        }
    }

    string CheckEsitenza_RenameFileAllegato(string strNomeFile, string tmpCurr)
    {
        int CurrentVersion = 1;

        //'-- FACCIO QUESTA REPLACE IN QUANTO SE PRESENTE ? nel nome file non viene scaricato
        strNomeFile = Replace(strNomeFile, "?", "_");

        string[] aInfoFile = Strings.Split(strNomeFile, ".");
        string ExtFile = aInfoFile[(aInfoFile.Length - 1)];

        //'--se stiamo nel caso di allegato firmato e c'� la doppia estensione metto il versioning prima del penultimo punto
        //'--es. test.pdf.p7m -> test[1].pdf.p7m
        if ((aInfoFile.Length - 1) >= 2)
        {
            ExtFile = aInfoFile[(aInfoFile.Length - 1) - 1] + "." + aInfoFile[aInfoFile.Length - 1];
        }

        string strHeadFile = Strings.Left(strNomeFile, strNomeFile.Length - (ExtFile.Length + 1));

        while (CommonStorage.FileExists(tmpCurr + strNomeFile))
        {
            strNomeFile = strHeadFile + "[" + CurrentVersion + "]" + "." + ExtFile;
            CurrentVersion = CurrentVersion + 1;
        }

        return strNomeFile;
    }

    string SogliaAllegatiSuperata(string cod)
    {
        string stringToReturn;
        TSRecordSet rs = cdf.GetRSReadFromQuery_("Select idrow from ctl_doc_value with (nolock) where idheader=" + cod + " and DSE_ID='SOGLIA_ALLEGATI' and DZT_NAME='MAX_SOGLIA_ALLEGATI_SUPERATA' and value='YES'", ApplicationCommon.Application.ConnectionString);

        stringToReturn = "NO";

        if (rs is not null)
        {
            if (rs.RecordCount > 0)
            {
                rs.MoveFirst();
                stringToReturn = "YES";
            }
            else
            {
                stringToReturn = "NO";
            }
        }
        return stringToReturn;
    }

    //'--Recupera il valore
    //'--Contesto = stringa che identifica l'oggetto tecnico in cui faccio la chiamata: nomepagina.asp,ecc....
    //'--Oggetto = attributo o altro su cui voglio recuperare la propriet�
    //'--Prop = proprieta ( i nomi sono come quelli definiti sui modelli)
    //'--DefValue = valore didefault
    //'--Idpfu = default passare -1
    string Get_Func_Property(string Contesto, string Oggetto, string Prop, string DefValue, string Idpfu)
    {
        string strToReturn;
        strToReturn = DefValue;

        //'--response.write "select dbo.parametri('" & Contesto & "','" & Oggetto & "','" & Prop & "','" & DefValue & "'," & Idpfu & ") as Valore "

        TSRecordSet rs = cdf.GetRSReadFromQuery_("select dbo.parametri('" + Contesto + "','" + Oggetto + "','" + Prop + "','" + DefValue + "'," + Idpfu + ") as Valore ", ApplicationCommon.Application.ConnectionString);
        if (rs.RecordCount > 0)
        {
            rs.MoveFirst();
            strToReturn = CStr(rs["Valore"]);
        }
        return strToReturn;
    }
    void ServerExecute(string urlPaginaChiamata, eProcurementNext.Session.ISession session, HttpRequest Request)
    {
        try
        {

            /* la pagina chiamata deve mantenere la sessione di lavoro del chiamante, sia per un giro di "sessione anonima" che di sessione autenticata */

            var cookieContainer = new CookieContainer();
            string? CookieValue = null;

            if (Request.Cookies.TryGetValue(eProcurementNext.Session.SessionMiddleware.Cookie_Auth_Name, out CookieValue))
                cookieContainer.Add(new Uri(Request.Scheme + "://" + Request.Host + "/"), new Cookie(eProcurementNext.Session.SessionMiddleware.Cookie_Auth_Name, CookieValue));

            if (Request.Cookies.TryGetValue(eProcurementNext.Session.SessionMiddleware.Cookie_Anon_Name, out CookieValue))
                cookieContainer.Add(new Uri(Request.Scheme + "://" + Request.Host + "/"), new Cookie(eProcurementNext.Session.SessionMiddleware.Cookie_Anon_Name, CookieValue));

            var handler = new HttpClientHandler() { CookieContainer = cookieContainer };
            HttpClient client = new HttpClient(handler);
            HttpResponseMessage message = new HttpResponseMessage();

            Dictionary<string, string> form = new Dictionary<string, string>();

            foreach (KeyValuePair<string, string> item in Request.Cookies)
            {
                form.Add(item.Key, item.Value);
            }
            if (Request.HasFormContentType)
            {
                foreach (KeyValuePair<string, StringValues> item in Request.Form)
                {
                    form.Add(item.Key, GetValueFromForm(Request, item.Key));
                }
            }

            FormUrlEncodedContent formUrlEncodedContent = new FormUrlEncodedContent(form);
            message = client.PostAsync(urlPaginaChiamata, formUrlEncodedContent).Result;

            //in caso di esito http negativo lanciamo un eccezione con lo status code e l'eventuale output ottenuto
            if (message is null || !message.IsSuccessStatusCode)
            {
                if (message is null)
                {
                    throw new Exception("Response null");
                }
                else
                {
                    throw new Exception($"ResponseStatusCode: {message.StatusCode}");
                }
            }

            var dummy = message.Content.ReadAsStringAsync().Result;

        }
        catch (Exception ex)
        {
            throw new Exception($"Richiesta ServerExecute({urlPaginaChiamata}) fallita. Exception: {ex.Message}", ex);
        }
    }
}
@Html.Raw(htmlToReturn.Out())